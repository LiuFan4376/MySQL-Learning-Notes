# MySQL-learning-notes
<!-- TOC -->

- [MySQL-learning-notes](#mysql-learning-notes)
  - [MySQL数据库基本操作](#mysql数据库基本操作)
    - [MySQL查看数据库(SHOW DATABASES语句)](#mysql查看数据库show-databases语句)
    - [MySQL创建数据库(CREATE DATABASE语句)](#mysql创建数据库create-database语句)
    - [MySQL修改数据库(ALTER DATABASE语句)](#mysql修改数据库alter-database语句)
    - [MySQL删除数据库(DROP DATABASE语句)](#mysql删除数据库drop-database语句)
    - [MySQL选择数据库(USE语句)](#mysql选择数据库use语句)
    - [MySQL注释](#mysql注释)
    - [MySQL中SQL语句大小写规则](#mysql中sql语句大小写规则)
    - [数据库设计基本步骤](#数据库设计基本步骤)
  - [MySQL数据类型和存储引擎](#mysql数据类型和存储引擎)
    - [整数类型](#整数类型)
    - [浮点数类型](#浮点数类型)
    - [日期时间类型](#日期时间类型)
    - [字符串类型](#字符串类型)
      - [ENUM类型](#enum类型)
      - [SET类型](#set类型)
    - [二进制类型](#二进制类型)
      - [BIT类型](#bit类型)
      - [BINARY 和 VARBINARY 类型](#binary-和-varbinary-类型)
    - [MySQL数据类型选择](#mysql数据类型选择)
      - [数值类型](#数值类型)
      - [字符串类型](#字符串类型-1)
    - [MySQL转义字符](#mysql转义字符)
    - [MySQL系统变量](#mysql系统变量)
      - [查看系统变量](#查看系统变量)
      - [设置系统变量](#设置系统变量)
    - [MySQL存储引擎](#mysql存储引擎)
  - [MySQL数据表操作](#mysql数据表操作)
    - [创建数据表(CREATE TABLE)](#创建数据表create-table)
    - [修改数据表(ALTER TABLE)](#修改数据表alter-table)
    - [删除数据表(DROP TABLES)](#删除数据表drop-tables)
    - [查看表结构(DESCRIBE)](#查看表结构describe)
  - [MySQL约束和运算符](#mysql约束和运算符)
    - [MySQL约束](#mysql约束)
    - [主键约束(PRIMARY KEY)](#主键约束primary-key)
      - [创建表时设置主键约束](#创建表时设置主键约束)
      - [表创建后设置主键约束](#表创建后设置主键约束)
      - [删除主键约束](#删除主键约束)
    - [主键自增长 (PRIMARY KEY AUTO\_INCREMENT)](#主键自增长-primary-key-auto_increment)
    - [外键约束(FOREIGN KEY)](#外键约束foreign-key)
      - [在创建表时设置外键约束](#在创建表时设置外键约束)
      - [表创建后设置外键约束](#表创建后设置外键约束)
    - [唯一约束(UNIQUE KEY)](#唯一约束unique-key)
    - [默认值(DEFAULT)](#默认值default)
    - [非空(NOT NULL)](#非空not-null)
    - [运算符](#运算符)
      - [算术运算符](#算术运算符)
      - [逻辑运算符](#逻辑运算符)
      - [比较运算符](#比较运算符)
      - [位运算符](#位运算符)
  - [MySQL操作数据表中的数据](#mysql操作数据表中的数据)
    - [添加数据(INSERT INTO)](#添加数据insert-into)
    - [修改数据(UPDATE)](#修改数据update)
    - [删除数据(DELETE)](#删除数据delete)
    - [查询数据(SELECT)](#查询数据select)
      - [DISTINCT去重](#distinct去重)
      - [AS指定别名](#as指定别名)
      - [WHERE条件查询](#where条件查询)
        - [模糊查询](#模糊查询)
        - [范围查询](#范围查询)
        - [空值查询](#空值查询)
      - [GROUP BY分组查询](#group-by分组查询)
      - [ORDER BY排序](#order-by排序)
      - [LIMIT限制查询结果条数](#limit限制查询结果条数)
    - [常函数](#常函数)
  - [多表查询](#多表查询)
    - [多表关系](#多表关系)
    - [交叉连接(CROSS JOIN)](#交叉连接cross-join)
    - [内连接(INNER JOIN)](#内连接inner-join)
    - [外连接](#外连接)
      - [左连接](#左连接)
      - [右连接](#右连接)
      - [外连接查询的其它使用场景](#外连接查询的其它使用场景)
        - [实现查询A-B](#实现查询a-b)
        - [实现查询B-A](#实现查询b-a)
    - [自连接](#自连接)
    - [联合查询(UNION)](#联合查询union)
    - [子查询](#子查询)
      - [标量子查询](#标量子查询)
      - [行列子查询](#行列子查询)
      - [表子查询](#表子查询)
  - [MySQL视图(VIEW)](#mysql视图view)
    - [创建视图](#创建视图)
    - [查看视图结构(DESCRIBE)](#查看视图结构describe)
    - [查询视图内容(SELECT)](#查询视图内容select)
    - [修改视图(ALTER VIEW)](#修改视图alter-view)
    - [删除视图(DROP VIEW)](#删除视图drop-view)
  - [MySQL索引(INDEX)](#mysql索引index)
    - [创建索引](#创建索引)
    - [查看索引(SHOW INDEX)](#查看索引show-index)
    - [删除索引](#删除索引)
  - [MySQL事务(TRANSACTION)](#mysql事务transaction)
    - [事务四大特征](#事务四大特征)
    - [执行事务语句](#执行事务语句)
  - [MySQL储存过程](#mysql储存过程)
    - [创建存储过程(CREATE PROCEDURE)](#创建存储过程create-procedure)
    - [查看存储过程](#查看存储过程)
    - [修改存储过程特征](#修改存储过程特征)
    - [删除存储过程](#删除存储过程)
    - [存储函数](#存储函数)
    - [调用存储过程和存储函数](#调用存储过程和存储函数)
      - [存储过程调用](#存储过程调用)
      - [存储函数调用](#存储函数调用)
    - [变量的使用](#变量的使用)
      - [定义变量](#定义变量)
      - [变量赋值](#变量赋值)
    - [流程控制语句-判断](#流程控制语句-判断)
      - [IF从句](#if从句)
      - [CASE从句](#case从句)
    - [流程控制语句-循环](#流程控制语句-循环)
      - [LOOP、LEAVE和ITERATE语句](#loopleave和iterate语句)
      - [REPEAT语句](#repeat语句)
      - [WHILE语句](#while语句)
    - [MySQL游标(CURSOR)](#mysql游标cursor)
      - [声明游标](#声明游标)
      - [打开游标](#打开游标)
      - [使用游标](#使用游标)
      - [关闭游标](#关闭游标)
  - [MySQL触发器](#mysql触发器)
    - [支持触发器类型](#支持触发器类型)
    - [触发器创建(CREATE TRIGGER)](#触发器创建create-trigger)
    - [查看触发器](#查看触发器)
    - [删除触发器](#删除触发器)
  - [用户管理](#用户管理)
    - [user表](#user表)
      - [用户列字段](#用户列字段)
      - [权限列字段](#权限列字段)
      - [安全列字段](#安全列字段)
      - [资源控制列](#资源控制列)
    - [查询用户](#查询用户)
    - [创建用户](#创建用户)
    - [删除用户](#删除用户)
    - [修改用户名](#修改用户名)
    - [用户权限管理](#用户权限管理)
      - [查询用户权限](#查询用户权限)
      - [授予用户权限](#授予用户权限)
      - [删除用户权限](#删除用户权限)
      - [权限类型](#权限类型)
        - [列权限](#列权限)
        - [数据表权限](#数据表权限)
        - [数据库权限](#数据库权限)
        - [用户权限](#用户权限)
    - [用户登录和退出](#用户登录和退出)
    - [用户修改密码](#用户修改密码)
      - [普通用户修改自己密码](#普通用户修改自己密码)
      - [root用户修改普通用户密码](#root用户修改普通用户密码)
      - [修改root用户密码](#修改root用户密码)

<!-- /TOC -->

## MySQL数据库基本操作

对数据库进行查询和修改操作的语言叫做 SQL（Structured Query Language，结构化查询语言）。SQL语句包含一下几个部分：

- 数据定义语言**DDL**

> 用来创建或删除数据库以及表等对象  
> `CREAATE`创建数据库或表对象；  
> `DROP`删除数据库或表对象；
> `ALTER`修改数据库和表对象；

- 数据操作语言**DML**

> 用来改变数据表里的记录  
> `SELECT`查询表里的记录  
> `INSERT`向表里插入记录  
> `UPGRADE`更新表里的记录  
> `DELETE`删除表里的记录

- 数据查询语言**DQL**

>用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。

- 数据控制语言**DCL**

>用来确认或者取消对数据库中的数据进行变更，设定用户的权限
>
>- `GRANT`：赋予用户操作权限
>- `REVOKE`：取消用户的操作权限
>- `COMMIT`：确认对数据库中的数据进行的变更
>- `ROLLBACK`：取消对数据库中的数据进行的变更

SQL语句书写规则：

- 每句以`;`结尾
- 不区分大小写，但通常关键字为大写，数据库或表名为小写
- 常数的书写方式固定：数字直接书写，不需要改变；字符串`''`单引号括起来；日期书写方式有`'2022-01-22'`、`'22/01/22'`
- 不同单次用半角空格或换行来分隔

### MySQL查看数据库(SHOW DATABASES语句)

语句为`SHOW DATABASES LIKE '数据库名'`  
语法说明如下：

- LIKE 从句是可选项，用于匹配指定的数据库名称。
- LIKE 从句可以部分匹配`%数据库名部分字段%'`，也可以完全匹配。数据库名由单引号' '包围。

```SQL
SHOW DATABASES;
结果：
Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sys                |
| world              |
+--------------------+
```

在上面的列表中有 6 个数据库，它们都是安装 MySQL 时系统自动创建的，其各自功能如下：

>- information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。
>- mysql：MySQL 的核心数据库，类似于 SQL Server 中的 master 表，主要负责存储数据库用户、用户访问权限等 MySQL 自己需要使用的控制和管理信息。常用的比如在 mysql 数据库的 user 表中修改 root 用户密码。
>- performance_schema：主要用于收集数据库服务器性能参数。
>- sakila：MySQL 提供的样例数据库，该数据库共有 16 张表，这些数据表都是比较常见的，在设计数据库时，可以参照这些样例数据表来快速完成所需的数据表。
>- sys：MySQL 5.7 安装完成后会多一个 sys 数据库。sys 数据库主要提供了一些视图，数据都来自于 performation_schema，主要是让开发者和使用者更方便地查看性能问题。
>- world：world 数据库是 MySQL 自动创建的数据库，该数据库中只包括 3 张数据表，分别保存城市，国家和国家使用的语言等内容。

### MySQL创建数据库(CREATE DATABASE语句)

语句:

```SQL
CREATE DATABASE [IF NOT EXISTS] 数据库名
 [[DEFAULT] CHARACTER SET 字符集名 ] 
 [[DEFAULT] COLLATE 校对规则名];
```

`[]`里的内容为可选选项。语句说明：  

>- 数据库名：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。
>- IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。
>- [DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。
>- [DEFAULT] COLLATE：指定字符集的默认校对规则

### MySQL修改数据库(ALTER DATABASE语句)

在 MySQL 数据库中只能对数据库使用的**字符集**和**校对规则**进行修改，数据库的这些特性都储存在 db.opt 文件中。
语句：

```SQL
ALTER DATABASE 数据库名 
CHARACTER SET 字符集名
COLLATE 校对规则名;
```

### MySQL删除数据库(DROP DATABASE语句)

当数据库不再使用时应该将其删除，以确保数据库存储空间中存放的是有效数据。删除数据库是将已经存在的数据库从磁盘空间上清除，清除之后，数据库中的所有数据也将一同被删除。语句格式:

```sql
DROP DATABASE IF EXISTS 数据库名；
```

IF EXISTS：用于防止当数据库不存在时发生错误。

### MySQL选择数据库(USE语句)

在 MySQL 中就有很多系统自带的数据库，那么在操作数据库之前就必须要确定是哪一个数据库。

```sql
USE 数据库名;
```

### MySQL注释

- 单行注释

`#注释内容`

- 多行注释

```sql
/*
注释内容
*/
```

### MySQL中SQL语句大小写规则

- **SQL 关键字和函数名**  
  不区分大小写

- **数据库名、表名和视图名**  
  区不区分大小写视操作系统类型决定：windows和MAC OS不区分，Linux区分。

- **存储程序的名字**  
  存储函数、存储过程和事件的名字都不区分大小写。触发器的名字要区分大小写，这一点与标准 SQL 的行为有所不同。

- **列名和索引名**  
  列名和索引名都不区分大小写。
- **别名的名字**  
  默认情况下，表的别名要区分大小写。

下表总结了 SQL 元素在 Windows 和 Linux 系统是否区分大小写。

||Windows|Linux|
|---|---|---|
|数据库名|否|是|
|表名|否|是|
|表别名|否|是|
|列名|否|否|
|列别名|否|否|
|变量名|否|是|

在 Linux 服务器下创建数据库和表时，应该认真考虑大小写的问题，比如它们以后是否会迁移到 Windows 服务器上。

### 数据库设计基本步骤

按照规范设计的方法，考虑数据库及其应用系统开发全过程，将数据库设计分为以下 6 个阶段：

- 需求分析  
  需求分析是数据库设计的第一步，是最困难、最耗费时间的一步，也是整个设计过程的基础。本阶段的主要任务是对现实世界中要处理的对象（公司、部门及企业，也可以理解成客户）进行详细调查，然后通过分析，逐步明确客户/用户对系统的需求，包括数据需求和业务处理需求。需求分析是否做的充分和准确，直接决定了在其上构建数据库大厦的速度与质量。需求分析做的不好，会导致整个数据库设计返工重做。
- 概要设计  
  概要设计是数据库设计的关键，通过综合、归纳与抽象用户需求，形成一个具体 DBMS 的概念模型，也就是绘制数据库的 E-R 图。E-R 图主要用于在项目团队内部，设计人员和客户之间进行沟通，确认需求信息的正确性和完整性。
- 逻辑结构设计  
  将 E-R 图转换为多张表，进行逻辑设计，确认各表的主外键，并应用数据库设计的三大范式进行审核，对其优化。在这阶段，E-R 图非常重要。大家要学会根据各个实体定义的属性来画出总体的 E-R 图。
- 物理设计阶段  
- 经项目组开会讨论确定 E-R 图后，根据项目的技术实现，团队开发能力及项目的成本预算，选择具体的数据库（如 MySQL 或 Oracle 等）进行物理实现。
- 数据库实施阶段  
  运用 DBMS 提供的数据语言（例如 SQL）、工具及宿主语言（例如 Java），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。
- 数据库运行和维护阶段
  数据库应用系统经过试运行后即可投入正式运行。在运行过程中必须不断地对其进行评价、调整与修改。

## MySQL数据类型和存储引擎

MySQL数据类型分为5类：整数类型、浮点数类型、日期时间类型、字符串类型和二进制类型。

### 整数类型

类型名称|说明|存储需求
---|---|---
TINYINT| -128〜127 |1个字节
SMALLINT| -32768〜32767| 2个字节
MEDIUMINT |-8388608〜8388607| 3个字节
INT (INTEGER) |-2147483648〜2147483647|4个字节
BIGINT |-9223372036854775808〜9223372036854775807 |8个字节

### 浮点数类型

类型名称|说明|存储需求
---|---|---
FLOAT|单精度浮点数|4个字节
DOUBLE|双精度浮点数|8个字节
DECIMAL(M,D)|压缩的“严格”定点数|M+2个字节

- DECIMAL(M, D)，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。
- 浮点数类型存在四舍五入忽略误差的问题，定点数不存在。

### 日期时间类型

MySQL 中有多处表示日期的数据类型：**YEAR、TIME、DATE、DTAETIME、TIMESTAMP**。
类型名称|格式|日期范围|存储需求
---|---|---|---|
YEAR|YYYY|1901 ~ 2155| 1 个字节
TIME |HH:MM:SS| -838:59:59 ~ 838:59:59 |3 个字节
DATE |YYYY-MM-DD |1000-01-01 ~ 9999-12-3 |3 个字节
DATETIME |YYYY-MM-DD HH:MM:SS| 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 |8 个字节
TIMESTAMP| YYYY-MM-DD HH:MM:SS |1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC| 4 个字节

- 如果同时需要记录日期和时间，则可以使用 TIMESTAMP 或者 DATETIME 类型。由于TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，因此存储较大的日期最好使用 DATETIME。
- TIMESTAMP 也有一个 DATETIME 不具备的属性。默认情况下，当插入一条记录但并没有指定 TIMESTAMP 这个列值时，MySQL 会把 TIMESTAMP 列设为当前的时间。因此当需要插入记录和当前时间时，使用 TIMESTAMP 是方便的，另外 TIMESTAMP 在空间上比 DATETIME 更有效。

### 字符串类型

MySQL 中的字符串类型有 **CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET**等。

类型名称|说明|存储需求
---|---|---
CHAR(M)| 固定长度非二进制字符串| M 字节，1<=M<=255
VARCHAR(M) |变长非二进制字符串 |L+1字节，在此，L< = M和 1<=M<=255
TINYTEXT| 非常小的非二进制字符串 |L+1字节，在此，L<2^8
TEXT |小的非二进制字符串| L+2字节，在此，L<2^16
MEDIUMTEXT| 中等大小的非二进制字符串| L+3字节，在此，L<2^24
LONGTEXT| 大的非二进制字符串| L+4字节，在此，L<2^32
ENUM| 枚举类型，只能有一个枚举字符串值| 1或2个字节，取决于枚举值的数目 (最大值为65535)
SET |一个设置，字符串对象可以有零个或 多个SET成员| 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）

说明：

- CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。
- VARCHAR(M) 是长度可变的字符串，最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。VARCHAR 在值保存和检索时尾部的空格仍保留。
- TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。

#### ENUM类型

是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：

  ```sql
  字段名 ENUM( '值1', '值1', …, '值n' )
  ```

ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且**一次只能取一个**。  
ENUM 值在内部用整数表示，**每个枚举值均有一个索引值**；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号。

#### SET类型

是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：

```sql
字段名 SET('值1','值2',...,'值n')
```

- 与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有**一个索引编号**。当创建表时，SET 成员值的尾部空格将自动删除。
- 但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中**选择多个字符的联合**。
- 如果插入 SET 字段中的列值有重复，则 MySQL **自动删除重复的值**；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，**按照定义的顺序显示**；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。

### 二进制类型

MySQL 中的**二进制字符串**有 **BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB**。
类型名称|说明|存储需求
---|---|---
BIT(M)| **位字段类型**| 大约 (M+7)/8 字节
BINARY(M) |固定长度二进制字符串 |M 字节
VARBINARY (M)| 可变长度二进制字符串|M+1 字节
TINYBLOB (M)| 非常小的BLOB| L+1 字节，在此，L<2^8
BLOB (M)| 小 BLOB |L+2 字节，在此，L<2^16
MEDIUMBLOB (M)| 中等大小的BLOB| L+3 字节，在此，L<2^24
LONGBLOB (M)| 非常大的BLOB| L+4 字节，在此，L<2^32

#### BIT类型

- 位字段类型。
- M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。
- 如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b'101'，其效果与分配 b'000101' 相同。

#### BINARY 和 VARBINARY 类型

- BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。
- BINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\0” 补齐，以达到指定长度。
- VARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。

### MySQL数据类型选择

#### 数值类型

- 如果要存储的数字是整数，则使用整数类型(在细分存储范围)；如果要存储的数字是小数（带有小数部分），则可以选用 DECIMAL 或浮点类型，但是一般选择 FLOAT 类型（浮点类型的一种）。
- 如果取值为正，则使用UNSIGNED 用来将数字类型无符号化。如：取值范围是 1~99999 之间的整数，则 MEDIUMINT UNSIGNED 类型是最好的选择。

#### 字符串类型

- CHAR 是固定长度，所以它的处理速度比 VARCHAR 的速度要快，但是它的缺点就是浪费存储空间。所以对存储不大，但在速度上有要求的可以使用 CHAR 类型，反之可以使用 VARCHAR类型来实现。
- 存储引擎对于选择 CHAR 和 VARCHAR 的影响:  
  >对于 MyISAM 存储引擎，最好使用固定长度的数据列代替可变长度的数据列。这样可以使整个表静态化，从而使数据检索更快，用空间换时间。  
  >对于InnoDB存储引擎，最好使用可变长度的数据列，因为 InnoDB 数据表的存储格式不分固定长度和可变长度，因此使用 CHAR 不一定比使用 VARCHAR 更好，但由于 VARCHAR 是按照实际的长度存储，比较节省空间，所以对磁盘 I/O 和数据存储总量比较好。
- ENUM 和 SET  
  >ENUM 只能取单值，它的数据列表是一个枚举集合。它的合法取值列表最多允许有 65 535个成员。因此，在需要从多个值中选取一个时，可以使用 ENUM。比如，性别字段适合定义，为 ENUM 类型，每次只能从‘男’或‘女’中取一个值。  
  >SET 可取多值。它的合法取值列表最多允许有 64 个成员。空字符串也是一个合法的 SET值。在需要取多个值的时候，适合使用 SET 类型，比如，要存储一个人兴趣爱好，最好使用SET类型。
- BLOB和TEXT  
  >BLOB 是二进制字符串，TEXT 是非二进制字符串，两者均可存放大容量的信息。BLOB 主要存储图片、音频信息等，而 TEXT 只能存储纯文本文件。

### MySQL转义字符

MySQL 中常见的转义字符如下表所示：
转义字符|说明
---|---
 \  " |双引号（"）
\  '| 单引号（'）
\  \  | 反斜线（\）
\n |换行符
\r |回车符
\t |制表符
\0 |ASCII 0（NUL）
\b| 退格符

### MySQL系统变量

 MySQL 数据库变量分为系统变量和用户自定义变量。**系统变量以 @@ 开头，用户自定义变量以 @ 开头**。  

 服务器维护着**两种系统变量**，**即全局变量（GLOBAL VARIABLES）**和**会话变量（SESSION VARIABLES**）。全局变量影响 MySQL 服务的整体运行方式，会话变量影响具体客户端连接的操作。

每一个客户端成功连接服务器后，都会产生与之对应的会话。会话期间，MySQL 服务实例会在服务器内存中生成与该会话对应的会话变量，这些会话变量的初始值是全局变量值的拷贝。

#### 查看系统变量

使用语句：

```sql
SHOW GLOBAL VARIABLES; 
SHOW SESSION VARIABLES;#SESSION 关键字可以省略。
```

- MySQL 中有一些系统变量仅仅是全局变量，例如 innodb_data_file_path，可以使用以下 3 种方法查看：  

```sql
SHOW GLOBAL VARIABLES LIKE 'innodb_data_file_path';
SHOW SESSION VARIABLES LIKE 'innodb_data_file_path';
SHOW VARIABLES LIKE 'innodb_data_file_path';
```

- MySQL 中有一些系统变量仅仅是会话变量，例如 MySQL 连接 ID 会话变量 pseudo_thread_id，可以使用以下 2 种方法查看。  
  
  ```sql
  SHOW SESSION VARIABLES LIKE 'pseudo_thread_id';  
  SHOW VARIABLES LIKE 'pseudo_thread_id';
  ```

- MySQL 中有一些系统变量既是全局变量，又是会话变量，例如系统变量 character_set_client 既是全局变量，又是会话变量。

 ```sql
  SHOW SESSION VARIABLES LIKE 'character_set_client';  
  SHOW VARIABLES LIKE 'character_set_client';
 ```

此时查看全局变量的方法如下：

```sql
SHOW GLOBAL VARIABLES LIKE 'character_set_client';
```

#### 设置系统变量

可以通过以下方法设置系统变量：

- 修改 MySQL 源代码，然后对 MySQL 源代码重新编译。
- 在 MySQL 配置文件（mysql.ini 或 mysql.cnf）中修改 MySQL 系统变量的值（需要重启 MySQL 服务才会生效）。
- 在 MySQL 服务运行期间，使用 SET 命令重新设置系统变量的值。

### MySQL存储引擎

## MySQL数据表操作

数据表是数据库的重要组成部分，每一个数据库都是由若干个数据表组成的。换句话说，没有数据表就无法在数据库中存放数据。

### 创建数据表(CREATE TABLE)

基本语法：

```SQL
CREATE TABLE 表名(
  字段1 数据类型,
  字段2 数据类型,
  、、、
  字段n 数据类型,
);

```

### 修改数据表(ALTER TABLE)

语法格式：

```sql
ALTER TABLE 表名 修改选项
```

修改选项包括([]里的内容代表可以忽略)：

- 添加字段  
  `ADD [COLUMN] 字段名 数据类型`  
- 删除字段  
  `DROP [COLUMN] 字段名`  
- 修改字段  
  `CHANGE [COLUMN] 旧字段名 新字段名 新数据类型 FIRST|AFTER 其它字段名`  
  `MODIFY [COLUMN] 字段名 新数据类型 FIRST|AFTER 指定字段名`  
  `FIRST`将新字段位置放在首位，`AFTER 指定字段名`将新字段放在自定字段啊后面
- 修改字段默认值  
  `ALTER [COLUMN] 字段名  SET DEFAULT 新默认值 | DROP DEFAULT`  
- 修改表名  
  `RENAME [TO] 新表名`
- 修改字符集及校对规则  
  `CHARACTER SET 字符集名 COLLATE 校对规则名;`

### 删除数据表(DROP TABLES)

语句格式：

```sql
DROP TABLES [IF EXISTS] 表名1,表明2,...；
```

**MySQL删除关联父表方法**：

- 先删除与它关联的子表，再删除父表；但是这样会同时删除两个表中的数据。
- 将关联表的外键约束取消，再删除父表；适用于需要保留子表的数据，只删除父表的情况。

### 查看表结构(DESCRIBE)

DESCRIBE/DESC 语句会以表格的形式来展示表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等，语法格式如下：  
`DESCRIBE <表名>;`  
或简写成：  
`DESC <表名>;`

## MySQL约束和运算符

### MySQL约束

约束是指对表中数据的一种约束，能够帮助数据库管理员更好地管理数据库，并且能够确保数据库中数据的正确性和有效性。在 MySQL 中，主要支持以下 6 种约束。

- 1）主键约束  
  主键约束是使用最频繁的约束。在设计数据表时，一般情况下，都会要求表中设置一个主键。  
  主键是表的一个特殊字段，该字段能唯一标识该表中的每条信息。例如，学生信息表中的学号是唯一的。
- 2）外键约束  
- 外键约束经常和主键约束一起使用，用来确保数据的一致性。  
  >例如，一个水果摊，只有苹果、桃子、李子、西瓜 4 种水果，那么，你来到水果摊要买水果只能选择苹果、桃子、李子和西瓜，不能购买其它的水果。
- 3）唯一约束  
  唯一约束与主键约束有一个相似的地方，就是它们都能够确保列的唯一性。与主键约束不同的是，唯一约束在一个表中可以有多个，并且设置唯一约束的列是允许有空值的，虽然只能有一个空值。  
  >例如，在用户信息表中，要避免表中的用户名重名，就可以把用户名列设置为唯一约束。
- 4）检查约束 **(MySQL失效)**
 检查约束是用来检查数据表中，字段值是否有效的一个手段。  
  > 例如，学生信息表中的年龄字段是没有负数的，并且数值也是有限制的。如果是大学生，年龄一般应该在 18~30 岁之间。在设置字段的检查约束时要根据实际情况进行设置，这样能够减少无效数据的输入。
- 5）非空约束  
  非空约束用来约束表中的字段不能为空。例如，在学生信息表中，如果不添加学生姓名，那么这条记录是没有用的。
- 6）默认值约束  
  默认值约束用来约束当数据表中某个字段不输入值时，自动为其添加一个已经设置好的值。  
  > 例如，在注册学生信息时，如果不输入学生的性别，那么会默认设置一个性别或者输入一个“未知”。
  
  默认值约束通常用在已经设置了非空约束的列，这样能够防止数据表在录入数据时出现错误。

以上 6 种约束中，**一个数据表中只能有一个主键约束，其它约束可以有多个**。

### 主键约束(PRIMARY KEY)

主键(PRIMARY KEY)是表的一个特殊字段，该字段能**唯一标识**该表中的每条信息。例如，学生信息表中的学号是唯一的。
主键分为**单字段主键**和**多字段联合主键**。

使用主键应注意以下几点：

- 每个表只能定义一个主键。
- 主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在有相同主键值的两行数据。这是唯一性原则。
- 一个字段名只能在联合主键字段表中出现一次。
- 联合主键不能包含不必要的多余字段。当把联合主键的某一字段删除后，如果剩下的字段构成的主键仍然满足唯一性原则，那么这个联合主键是不正确的。这是最小化原则。

#### 创建表时设置主键约束

- 设置单主键约束  
  在 CREATE TABLE 语句中，通过 PRIMARY KEY 关键字来指定主键，语法格式如下：

```sql
CREATE TABLE 表名(
  字段名 数据类型 PRIMARY KEY [默认值]);
或
CREATE TABLE 表名(
  字段名 数据类型  [默认值],
  PRIMARY KEY(字段名));
```

- 设置联合主键  
  所谓的联合主键，就是这个主键是由一张表中多个字段组成的。  
  > 比如，设置学生选课数据表时，使用学生编号做主键还是用课程编号做主键呢？如果用学生编号做主键，那么一个学生就只能选择一门课程。如果用课程编号做主键，那么一门课程只能有一个学生来选。显然，这两种情况都是不符合实际情况的。实际上设计学生选课表，要限定的是一个学生只能选择同一课程一次。因此，学生编号和课程编号可以放在一起共同作为主键，这也就是联合主键了。

  语法格式如下:

  ```sql
  CREATE TABLE 表名(
    字段1 数据类型 [默认值],
    字段2 数据类型 [默认值],
    PRIMARY KEY (字段1，字段2)
  )
  ```

#### 表创建后设置主键约束

语句格式如下：

```sql
ALTER TABLE 表名 ADD PRIMARY KEY 字段名 [默认值];
```

#### 删除主键约束

语句格式如下：

```sql
ALTER  TABLE 表名 DROP PRIMARY KEY;
```

因为主键只有一个，所以不需要指明字段名。

### 主键自增长 (PRIMARY KEY AUTO_INCREMENT)

在 MySQL中，当主键定义为自增长后，**这个主键的值就不再需要用户输入数据，而由数据库系统根据定义自动赋值。每增加一条记录，主键会自动以相同的步长进行增长**。

通过给字段添加 AUTO_INCREMENT 属性来实现主键自增长。语法格式如下：

```sql
字段名 数据类型 PRIMARY KEY AUTO_INCREMENT
```

说明：

- 默认情况下，AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1。
- **一个表中只能有一个字段使用 AUTO_INCREMENT 约束**，且该字段必须有唯一索引，以避免序号重复（即为主键或主键的一部分）。
- AUTO_INCREMENT 约束的字段必须具备 NOT NULL 属性。
- AUTO_INCREMENT 约束的字段**只能是整数类型**（TINYINT、SMALLINT、INT、BIGINT 等）。
- AUTO_INCREMENT 约束字段的最大值受该字段的数据类型约束，如果达到上限，AUTO_INCREMENT 就会失效。

**指定自增字段初始值**  
如果第一条记录设置了该字段的初始值，那么新增加的记录就从这个初始值开始自增，语句格式如下：

```sql
CREATE TABLE 表名(
  字段1 INT AUTO_INCREMENT,
  PRIMARY KEY(字段1)
  )
  AUTO_INCREMENT=初始值;
```

### 外键约束(FOREIGN KEY)

MySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，**相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）**。外键约束是指用于在两个表之间建立关系，需要指定引用主表的哪一列。

定义外键时，需要遵守下列规则：

- 主表必须已经存在于数据库中，或者是当前正在创建的表。
- 必须为主表定义主键，主键不能包含空值，但允许在外键中出现空值。
- 外键中列的数目必须和主表的主键中列的数目相同。
外键中列的数据类型必须和主表主键中对应列的数据类型相同。

#### 在创建表时设置外键约束

语法格式如下：

```sql
CREATE TABLE 表名(
  字段1 数据类型,
  字段2 数据类型,
 [CONSTRAINT 约束名称] 
 FOREIGN KEY (字段1,字段2) REFERENCES 主表名 (主键字段1,主键字段2)
 # constraint  外键约束名称  foreign key(外键的字段名称)  references 主表表名(主键字段名)
);
```

#### 表创建后设置外键约束

语句格式：

```sql
ALTER TABLE 数据表名 ADD CONSTRAINT 约束名称
FOREIGN KEY(外键名) REFERENCES 主表名 (主键名);
```

### 唯一约束(UNIQUE KEY)

### 默认值(DEFAULT)

### 非空(NOT NULL)

### 运算符

#### 算术运算符

#### 逻辑运算符

#### 比较运算符

#### 位运算符

## MySQL操作数据表中的数据

### 添加数据(INSERT INTO)

语句格式如下：

```sql
/*
向指定字段添加数据，对于未指定的字段自动设置为默认值。

*/
INSERT INTO 表名 (字段1,字段2,...,字段n) 
VALUES (值1,值2,值n);
/*
向全部字段添加记录
*/
INSERT INTO 表名 
VALUES (值1,值2,...);
/*
添加多条记录
*/
INSERT INTO 表名 
VALUES (值1,值2,...), (值1,值2,...),...;
```

说明：

- VALUES 或 VALUE 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。
- 字符串和日期类型数据应该包含在引号中
- 插入的数据大小应该在字段的规定范围内

### 修改数据(UPDATE)

语法格式如下：

```sql
UPDATE 表名 
SET 字段1=值1,字段2=值2,... 
WHERE 子句
ORDER BY 子句
LIMIT 子句
;
```

语法说明如下：

- SET 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。
- WHERE 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。
- ORDER BY 子句：可选项。用于限定表中的行被修改的次序。
- LIMIT 子句：可选项。用于限定被修改的行数。

### 删除数据(DELETE)

语句格式如下：

```sql
DELETE FROM 表名 
WHERE 子句 
LIMIT 子句
ORDER BY 子句
; 
```

语法说明如下：

- ORDER BY 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。
- WHERE 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。
- LIMIT 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。

删除一张表的全部数据可以用`TRUNCATE` 关键字，语法格式如下：

```sql
TRUNCATE [TABLE] 表名
```

### 查询数据(SELECT)

语句格式如下：

```sql
SELECT 字段1,字段2,... 或者 *  FROM 表1,表2,...
/*
条件子句
*/
WHERE 条件列表
GROUP BY 分组字段列表 HAVING 分组后的条件列表
ORDER BY 排序列表
LIMIT 分页参数
```

语句说明：

- WHERE <表达式>是可选项，如果选择该项，将限定查询数据必须满足该查询条件。
- GROUP BY< 字段 >，该子句告诉 MySQL 如何显示查询出来的数据，并按照指定的字段分组。
- [ORDER BY< 字段 >]，该子句告诉 MySQL 按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。
- [LIMIT[<offset>，]<row count>]，该子句告诉 MySQL 每次显示查询出来的数据条数。

#### DISTINCT去重

SELECT数据查询时，如果返回记录的某些字段没有唯一性约束，那么这些字段就可能存在重复值。为了实现查询不重复的数据，MySQL 提供了 DISTINCT 关键字。

语句格式如下:

```sql
SELECT DISTINCT 字段名 FROM 表名;
```

说明：

- 在对一个或多个字段去重时，DISTINCT 关键字必须在所有字段的最前面。
- 如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重。

#### AS指定别名

为了查询方便，MySQL 提供了 AS 关键字来为表和字段指定别名。

语句格式如下：

```sql
表名/字段名 [AS] 新表名/字段名
```

AS关键字可以省略，省略后需要将表名和别名用空格隔开。

#### WHERE条件查询

如果需要有条件的从数据表中查询数据，可以使用 WHERE 关键字来指定查询条件。

```sql
WHERE 查询条件
```

查询条件可以是：

- 带比较运算符和逻辑运算符的查询条件
- 带 BETWEEN AND 关键字的查询条件
- 带 IS NULL 关键字的查询条件
- 带 IN 关键字的查询条件
- 带 LIKE 关键字的查询条件(记录的某一关键字含有指定字段)

##### 模糊查询

`LIKE` 关键字主要用于搜索匹配字段中的指定内容。其语法格式如下：

```sql
字段 [NOT] LIKE  '字符串'
```

语句说明:

- NOT ：可选参数，字段中的内容与指定的字符串不匹配时满足条件。
- 字符串：指定用来匹配的字符串。“字符串”可以是一个很完整的字符串，也可以包含通配符。LIKE 关键字支持百分号“%”和下划线“_”通配符。

>通配符是一种特殊语句，主要用来模糊查询。当不知道真正字符或者懒得输入完整名称时，可以使用通配符来代替一个或多个真正的字符。

- “%”是 MySQL 中最常用的通配符，它能代表任何长度的字符串，字符串的长度可以为 0。
  >例如，a%b表示以字母 a 开头，以字母 b 结尾的任意长度的字符串。该字符串可以代表 ab、acb、accb、accrb 等字符串。
- “_”只能代表单个字符，字符的长度不能为 0。
- 默认情况下，LIKE 关键字匹配字符的时候是不区分大小写的。如果需要区分大小写，可以加入 BINARY 关键字。

```sql
字段 LIKE BINARY '字符串'
```

>**使用通配符的注意事项和技巧**  
下面是使用通配符的一些注意事项：  
>
>- 注意大小写。MySQL 默认是不区分大小写的。如果区分大小写，像“Tom”这样的数据就不能被“t%”所匹配到。
>- 注意尾部空格，尾部空格会干扰通配符的匹配。例如，“T% ”就不能匹配到“Tom”。
>- 注意 NULL。“%”通配符可以到匹配任意字符，但是不能匹配 NULL。也就是说 “%”匹配不到 tb_students_info 数据表中值为 NULL 的记录。

>**下面是一些使用通配符要记住的技巧。**
>
>- 不要过度使用通配符，如果其它操作符能达到相同的目的，应该使用其它操作符。因为 MySQL 对通配符的处理一般会比其他操作符花费更长的时间。
>- 在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。
>- 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。
>- 如果查询内容中包含通配符，可以使用“\\%”转义符表示'%'。

##### 范围查询

BETWEEN AND 需要两个参数，即范围的起始值和终止值。如果字段值在指定的范围内，则这些记录被返回。如果不在指定范围内，则不会被返回。  

语句格式如下

```sql
字段 [NOT] BETWEEN 值1 AND 值2
```

- NOT：可选参数，表示指定范围之外的值。如果字段值不满足指定范围内的值，则这些记录被返回。
- 取值1：表示范围的起始值。
- 取值2：表示范围的终止值。

##### 空值查询

如果字段的值是空值，则满足查询条件，该记录将被查询出来。如果字段的值不是空值，则不满足查询条件。

语法格式如下：

```sql
字段 IS [NOT] NULL
```

其中，“NOT”是可选参数，表示字段值不是空值时满足条件。

注意：IS NULL 是一个整体，**不能将 IS 换成“=”**。如果将 IS 换成“=”将不能查询出任何结果，数据库系统会出现“Empty set(0.00 sec)”这样的提示。同理，IS NOT NULL 中的 IS NOT 不能换成“!=”或“<>”。

#### GROUP BY分组查询

GROUP BY 关键字可以根据一个或多个字段对查询结果进行分组。

语句格式如下:

```sql
SELECT 分组关键字, [聚合函数(关键字)],[GROUP_CONCAT(关键字) 
]
FROM 表名
WHERE 分组前条件查询列表
GROUP BY 分组关键字 [WITH ROLLUP] HAVING 分组后条件查询列表
```

常见聚合函数：
|函数 |功能
|---|---
count| 统计数量
max |最大值
min| 最小值
avg |平均值
sum| 求和

说明：

- 分组之后，**查询的字段一般为聚合函数和分组字段**，查询其他字段无任何意义。
- 分组后的表字段与原查询表字段不同，变成了查询语句显示字段。
- 聚合函数用于分组统计(多值变单值)，例如：  

```sql
  -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）
select count(*) from employee group by gender;
-- 根据性别分组，统计男性和女性数量
select gender, count(*) from employee group by gender;
-- 根据性别分组，统计男性和女性的平均年龄
select gender, avg(age) from employee group by gender;
-- 年龄小于45，并根据工作地址分组
select workaddress, count(*) from employee where age < 45 group by workaddress;
-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址
select workaddress, count(*) address_count from employee where age < 45 group by workaddress having address_count >= 3;
 ```

- GROUP_CONCAT() 函数会把每个分组的字段值都显示出来
- 执行顺序：where > 聚合函数 > having

#### ORDER BY排序

语句格式如下：

```sql
ORDER BY 字段1 排序方式1, 字段2 排序方式2;
```

- 排序方式有：ASC表示字段按升序排序；DESC表示字段按降序排序
- 指定多个字段进行排序时，MySQL 会按照字段的顺序从左到右依次进行排序。

#### LIMIT限制查询结果条数

LIMIT 是 MySQL 中的一个特殊关键字，用于指定查询结果从哪条记录开始显示，一共显示多少条记录。

语句格式：

```sql
/*指定初始位置
注意：第一条记录的位置是 0，LIMIT 后的两个参数必须都是正整数。*/
LIMIT 初始位置 记录条数
或
LIMIT 记录数 OFFSET 初始位置
/*不指定初始位置
LIMIT 关键字不指定初始位置时，记录从第一条记录开始显示。显示记录的条数由 LIMIT 关键字指定。
*/
LIMIT 记录条数
```

### 常函数

几类函数的使用范围：

- **数学函数**  
  主要用于处理数字，这类函数包括绝对值函数、正弦函数、余弦函数和获得随机数的函数等。
- **字符串函数**  
  主要用于处理字符串，其中包括字符串连接函数、字符串比较函数、将字符串的字母都变成小写或大写字母的函数和获取子串的函数等。
- **日期和时间函数**  
  主要用于处理日期和时间。其中包括获取当前时间的函数、获取当前日期的函数、返回年份的函数和返回日期的函数等。
- **条件判断函数**  
  主要用于在 SQL 语句中控制条件选择。其中包括 IF 语句、CASE 语句和 WHERE 语句等。
- **系统信息函数**  
  主要用于获取 MySQL 数据库的系统信息。其中包括获取数据库名的函数、获取当前用户的函数和获取数据库版本的函数等。
- **加密函数**  
  主要用于对字符串进行加密解密。其中包括字符串加密函数和字符串解密函数等。

其他函数主要包括格式化函数和锁函数等。
参考链接[MySQL函数大全](http://c.biancheng.net/mysql/function/ )

## 多表查询

前面所讲的查询语句都是针对一个表的，但是在关系型数据库中，表与表之间是有联系的，所以在实际应用中，经常使用多表查询。多表查询就是同时查询两个或两个以上的表。

多表连接查询的分类：

- 交叉连接查询:`CROSS JOIN`
- 内连接查询: `[INNER] JOIN`
- 外连接:`LEFT [OUTER] JOIN, RIGHT [OUTER] JOIN`
- 自连接查询
- 联合查询：`UNION`

### 多表关系

- 一对多
>
> 案例：部门与员工  
> 关系：一个部门对应多个员工，一个员工对应一个部门
>实现：在多的一方建立外键，指向一的一方的主键

- 多对多

> 案例：学生与课程  
> 关系：一个学生可以选多门课程，一门课程也可以供多个学生选修  
> 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键

- 一对一

> 案例：用户与用户详情  
> 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率  
> 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）

### 交叉连接(CROSS JOIN)

交叉连接（CROSS JOIN）一般用来返回连接表的笛卡尔积。

语句格式如下：

```sql
SELECT 查询字段列表 FROM 表1 CROSS JOIN 表2
[条件语句];/*条件语句是在连接查询之后对记录进行过滤*/
或
SELECT 查询字段列表 FROM 表1,表2
[条件语句]
```

说明：  
如果在交叉连接时使用 WHERE 子句，MySQL 会先生成两个表的笛卡尔积，然后再选择满足 WHERE 条件的记录。因此，表的数量较多时，交叉连接会非常非常慢。一般情况下不建议使用交叉连接。

> **笛卡尔积**  
> 笛卡尔积（Cartesian product）是指两个集合 X 和 Y 的乘积。  
> 例如，有 A 和 B 两个集合，它们的值如下：  
> A = {1,2}
> B = {3,4,5}  
> 集合 A×B 和 B×A 的结果集分别表示为：  
> A×B={(1,3), (1,4), (1,5), (2,3), (2,4), (2,5) };  
> B×A={(3,1), (3,2), (4,1), (4,2), (5,1), (5,2) };  
> 以上 A×B 和 B×A 的结果就叫做两个集合的笛卡尔积。  
>并且，从以上结果我们可以看出：
两个集合相乘，不满足交换率，即 A×B≠B×A。
A 集合和 B 集合的笛卡尔积是 A 集合的元素个数 × B 集合的元素个数。

### 内连接(INNER JOIN)

连接（INNER JOIN）主要通过设置连接条件的方式，来滤除查询结果中某些数据行的交叉连接。

内连接使用 INNER JOIN 关键字连接两张表，并使用 ON 子句来设置连接条件，一般连接条件是用来**取满足某一条件的两张表记录的交集部分**。

![图片alt](%E5%86%85%E8%BF%9E%E6%8E%A5.png "图片title")

如果没有连接条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的，两者可以互换。

应用场景：

内连接的语法格式如下：

```sql
/*需要指明查询的字段来源于哪一张表, 格式为:表名.字段名*/
SELECT 查询字段 FROM 表1 INNER JOIN 表2 
ON 条件语句;

/*
例子
*/
select e.name, d.name from employee as e inner join dept as d 
on e.dept = d.id;
```

### 外连接

内连接的查询结果都是符合连接条件的记录，而外连接会先将连接的表分为基表和参考表，再以基表为依据返回满足和不满足条件的记录。

#### 左连接

语句格式如下

```sql
SELECT 查询字段 FROM 表1 LEFT [OUTER] JOIN 表2
ON 连接条件;
```

说明：

- 上述语法中，“表1”为基表，“表2”为参考表。
- 左连接查询时，可以**查询出“表1”中的所有记录**和“表2”中**匹配连接条件的记录**。
- 如果“表1”的某行在“表2”中没有匹配行，那么在返回结果中，“表2”的字段值均为空值（NULL）。

![图片alt](左连接.png "图片title")

#### 右连接

语句格式如下：

```sql
SELECT 查询字段 FROM 表1 RIGHT [OUTER] JOIN 表2
ON 连接条件;
```

- 上述语法中，“表1”为参考表，“表2”为基表。
- 左连接查询时，可以**查询出“表2”中的所有记录**和**表1中匹配连接条件的记录**。
- 如果“表1”的某行在“表2”中没有匹配行，那么在返回结果中，“表1”的字段值均为空值（NULL）。

![图片alt](右连接.png "图片title")

#### 外连接查询的其它使用场景

##### 实现查询A-B

语句格式如下：

```sql
SELECT 查询字段 表A LEFT JOIN 表B 
ON 连接条件
WHERE 表B.字段 IS NULL;
```

![图片alt](B的补集.png "图片title")

##### 实现查询B-A

语句格式如下：

```sql
SELECT 查询字段 FROM 表A RIGHT JOIN 表B 
ON 连接条件
WHERE A.字段 IS NULL;
```

![图片alt](A的补集.png "图片title")

### 自连接

当前表与自身的连接查询，**自连接必须使用表别名**

语句格式如下：

```sql
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B 
ON 条件 ...;

/*自连接查询，可以是内连接查询，也可以是外连接查询*/

/*例子：*/
/* 查询员工及其所属领导的名字*/
select a.name, b.name from employee a, employee b where a.manager = b.id;
-- 没有领导的也查询出来
select a.name, b.name from employee a left join employee b on a.manager = b.id;
```

### 联合查询(UNION)

联合查询结果是将多个select语句的查询结果联合到一起。可以使用union和union all关键字进行合并。

基本语法：

```sql
select 语句1
union [ALL或者DISTINCT]
select 语句2
union [ALL或者DISTINCT]
select 语句n
```

说明：

- 其中union选项有两个选项可选：all（表示重复也输出）；distinct（去重，完全重复的，默认会去重）
- 多条查询语句的查询字段需要相同。

例：

```sql
select id,addrid from addr 
union all 
select id,addrid from student
```

### 子查询

子查询指将一个查询语句嵌套在另一个查询语句中。  

子查询可以在 SELECT、UPDATE 和 DELETE 语句中使用，而且可以进行多层嵌套。  

根据子查询位置可以在WHERE、FROM、SELECT之后。在实际开发时，子查询经常出现在 WHERE 子句中。

语句格式如下:

```sql
WHERE 表达式 操作符 (子查询语句)
```

其中，操作符可以是比较运算符和 IN、NOT IN、EXISTS、NOT EXISTS 等关键字。

- IN | NOT IN  
  当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回值正好相反。
- EXISTS | NOT EXISTS  
  用于判断子查询的结果集是否为空，若子查询的结果集不为空，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。

例子

```sql
/*
使用子查询在 tb_students_info 表和 tb_course 表中查询学习 Java 课程的学生姓名
*/
SELECT NAME FROM tb_students_info 
WHERE course_id IN (SELECT id FROM tb_course WHERE course_name = 'Java');
/*
1）首先单独执行内查询，查询出 tb_course 表中课程为 Java 的 id
2）然后执行外层查询，在 tb_students_info 表中查询 course_id 等于 1 的学生姓名。
*/
```

习惯上，外层的 SELECT 查询称为父查询，圆括号中嵌入的查询称为子查询（子查询必须放在圆括号内）。MySQL 在处理上例的 SELECT 语句时，执行流程为：**先执行子查询，再执行父查询**。

根据子查询结果可以分为：

- 单值查询（子查询结果为单个值）
- 行列子查询(子查询结果为一行或一列数据)
- 表子查询（子查询结果为多行多列）

#### 标量子查询

子查询返回的结果是**单个值**（数字、字符串、日期等）。

常用操作符：- < > > >= < <=

例子：

```sql
-- 查询销售部所有员工
select id from dept where name = '销售部';
-- 根据销售部部门ID，查询员工信息
select * from employee where dept = 4;
-- 合并（子查询）
select * from employee where dept = (select id from dept where name = '销售部');
-- 查询xxx入职之后的员工信息
select * from employee where entrydate > (select entrydate from employee where name = 'xxx');
```

#### 行列子查询

返回的结果是一列（可以是多行）。

常用操作符：IN,NOT IN,ANY,SOME,ALL

> ANY,SOME表示任意；  
> ALL表示全部;  
> 三者通常配合比较运算符使用

例子：

```sql
-- 查询销售部和市场部的所有员工信息
select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');
-- 查询比财务部所有人工资都高的员工信息
select * from employee where salary > all(select salary from employee where dept = (select id from dept where name = '财务部'));
-- 查询比研发部任意一人工资高的员工信息
select * from employee where salary > any (select salary from employee where dept = (select id from dept where name = '研发部'));
```

#### 表子查询

返回的结果是多行多列
常用操作符：IN

例子：

```sql
-- 查询与xxx1，xxx2的职位和薪资相同的员工
select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2');
-- 查询入职日期是2006-01-01之后的员工，及其部门信息
select e.*, d.* from (select * from employee where entrydate > '2006-01-01') as e left join dept as d on e.dept = d.id;
```

**子查询结果返回多行多列数据记录，可以当作一张临时表，需要指定别名**。

## MySQL视图(VIEW)

视图在数据库中的作用类似于窗户，用户可以通过这个窗口看到只对自己有用的数据。既保障了数据的安全性，又大大提高了查询效率。

### 创建视图

语句格式：

```sql
CREATE VIEW 视图名称 [(字段列表)]
AS 创建视图的数据源，比如SELECT语句等
```

注意：

- 如果字段列表省略则视图显示的字段名称为查询记录表的字段名称
- SELECT 语句不能引用系统或用户变量。  
- SELECT 语句不能包含 FROM 子句中的子查询。  
- SELECT 语句不能引用预处理语句参数。

### 查看视图结构(DESCRIBE)

语句格式如下：

```sql
DESCRIBE 视图名
```

### 查询视图内容(SELECT)

语句格式如下：

```sql
SELECT 显示字段 FROM 视图名;
```

### 修改视图(ALTER VIEW)

基本语法格式：

```sql
ALTER VIEW 视图名 AS 新的视图数据源
```

说明：  
视图是一个虚拟表，实际的数据来自于基本表，所以通过插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。

### 删除视图(DROP VIEW)

语句格式如下：

```sql
DROP VIEW 视图1,视图2,...;
```

## MySQL索引(INDEX)

在 MySQL 中，通常有以下两种方式访问数据库表的行数据：

- 顺序访问  
  顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。  
  顺序访问实现比较简单，但是当表中有大量数据的时候，效率非常低下。  
- 索引访问  
  索引访问是通过遍历索引来直接访问表中记录行的方式。  
  使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。  
  > 例如，在学生基本信息表 tb_students 中，如果基于 student_id 建立了索引，系统就建立了一张索引列到实际记录的映射表。当用户需要查找 student_id 为 12022 的数据的时候，系统先在 student_id 索引上找到该记录，然后通过映射表直接找到数据行，并且返回该行数据。因为扫描索引的速度一般远远大于扫描实际数据行的速度，所以采用索引的方式可以大大提高数据库的工作效率。

索引的缺陷：

- 创建和维护索引组要耗费时间；
- 索引需要占磁盘空间；
- 当对表中的数据进行增加、删除和修改的时候，索引也要动态维护。
- 索引可以提高查询速度，但是会影响插入记录的速度。
  > 因为，向有索引的表中插入记录时，数据库系统会按照索引进行排序，这样就降低了插入记录的速度，插入大量记录时的速度影响会更加明显。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后，再创建索引。

### 创建索引

语句格式如下：

```sql
--方法1：在已有表上创建索引
CREATE [索引类型参数] INDEX 索引名 
ON 表名(字段名 [长度] [ASC或DESC]);

或者

ALTER TABLE 表名 
ADD INDEX [索引名] [索引类型参数] (字段名);

--方法2：在表创建时设置索引

CREATE TABLE 表名(
  字段名 数据类型,
  INDEX [索引名] [索引类型参数] (字段名)
)

```

语句说明：

- 索引名：指定索引名。一个表可以创建多个索引，但每个索引在该表
- 列名：指定要创建索引的列名。通常可以考虑将查询语句中在 JOIN 子句和 WHERE 子句里经常出现的列作为索引列。
- 长度：可选项。指定使用列前的 length 个字符来创建索引。使用列的一部分创建索引有利于减小索引文件的大小，节省索引列所占的空间。在某些情况下，只能对列的前缀进行索引。索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，BLOB 或 TEXT 类型的列也必须使用前缀索引。
- ASC|DESC：可选项。ASC指定索引按照升序来排列，DESC指定索引按照降序来排列，默认为ASC。

### 查看索引(SHOW INDEX)

语句格式如下：

```sql
SHOW INDEX FROM 表名 [FROM 数据库名]
```

### 删除索引

语句格式如下：

```sql
ALTER TABLE 表名 DROP INDEX 索引名 ;
或者
DROP INDEX 索引名 ON 表名; 
```

## MySQL事务(TRANSACTION)

当多个用户访问同一数据时，一个用户在更改数据的过程中可能有其它用户同时发起更改请求，为保证数据的一致性状态，MySQL 引入了事务。

事务的定义：

- 一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)
- 一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成
- 事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同

> 转账操作理解事务
> 假设A对B转账100元，那么需要两步操作：
>
> - A的账户扣100元
> - B的账户加100元  
>
>以上两句DML语句必须同时成功或者同时失败。最小单元不可再分，当第一条DML语句执行成功后，并不能将底层数据库中的第一个账户的数据修改，只是将操作记录了一下；这个记录是在内存中完成的；当第二条DML语句执行成功后，和底层数据库文件中的数据完成同步。若第二条DML语句执行失败，则清空所有的历史操作记录，要完成以上的功能必须借助事务。

### 事务四大特征

- 原子性(A)：事务是最小单位，不可再分

> 事务中的所有元素必须作为一个整体提交或回滚。如果事务中的任何元素失败，则整个事务将失败。  
> 以银行转账事务为例，如果该事务提交  了，则这两个账户的数据将会更新。如果由于某种原因，事务在成功更新这两个账户之前终止了，则不会更新这两个账户的余额，并且会撤销对任何账户余额的修改，事务不能部分提交。

- 一致性(C)：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败

> 以银行转账事务事务为例。在事务开始之前，所有账户余额的总额处于一致状态。在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。因此，所有账户余额的总额处于不一致状态。事务完成以后，账户余额的总额再次恢复到一致状态。

- 隔离性(I)：事务A和事务B之间具有隔离性

> 对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。  
>
> 另外，当事务修改数据时，如果任何其他进程正在同时使用相同的数据，**则直到该事务成功提交之后，对数据的修改才能生效**。张三和李四之间的转账与王五和赵二之间的转账，永远是相互独立的。

- 持久性(D)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)

> 一个事务成功完成之后，它对数据库所作的改变是永久性的，即使系统出现故障也是如此。也就是说，一旦事务被提交，事务对数据所做的任何变动都会被永久地保留在数据库中。

### 执行事务语句

语句格式如下：

```sql
-- 1.开启事务
BEGIN TRANSACTION; 
或
START TRANSACTION;

--2.执行DML语句
SELECT、DELET和UPDATE语句

--3. 提交事务
COMMIT;
/*
提交事务，意味着将事务开始以来所执行的所有数据都修改成为数据库的永久部分，
因此也标志着一个事务的结束。一旦执行了该命令，将不能回滚事务。
只有在所有修改都准备好提交给数据库时，才执行这一操作。
*/

或者

-- 回滚撤销
ROLLBACK;
/*
当事务执行过程中遇到错误时，使用 ROLLBACK 语句使事务回滚到起点或指定的保持点处。
同时，系统将清除自事务起点或到某个保存点所做的所有的数据修改，并且释放由事务控制的资源。因此，这条语句也标志着事务的结束。
*/
```

## MySQL储存过程

存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个**指定名称**存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用`CALL存储过程名字`即可自动完成。

一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由 SQL 语句和一些特殊的控制结构组成。

MySQL 5.0 版本以前并不支持存储过程，这使 MySQL 在应用上大打折扣。MySQL 从 5.0 版本开始支持存储过程，既提高了数据库的处理速度，同时也提高了数据库编程的灵活性

存储过程有如下优点：

1) 封装性  
   通常完成一个逻辑功能需要多条 SQL 语句，而且各个语句之间很可能传递参数，所以，编写逻辑功能相对来说稍微复杂些，而存储过程可以把这些 SQL 语句包含到一个独立的单元中，使外界看不到复杂的 SQL 语句，只需要简单调用即可达到目的。并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。
2) 可增强 SQL 语句的功能和灵活性  
   存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。
3) 可减少网络流量  
   由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。
4) 高性能  
   当存储过程被成功编译后，就存储在数据库服务器里了，以后客户端可以直接调用，这样所有的 SQL 语句将从服务器执行，从而提高性能。但需要说明的是，存储过程不是越多越好，过多的使用存储过程反而影响系统性能。
5) 提高数据库的安全性和数据的完整性  
   存储过程提高安全性的一个方案就是把它作为中间组件，存储过程里可以对某些表做相关操作，然后存储过程作为接口提供给外部程序。这样，外部程序无法直接操作数据库表，只能通过存储过程来操作对应的表，因此在一定程度上，安全性是可以得到提高的。
6) 使数据独立  
   数据的独立可以达到解耦的效果，也就是说，程序可以调用存储过程，来替代执行多条的 SQL 语句。这种情况下，存储过程把数据同用户隔离开来，优点就是当数据表的结构改变时，调用表不用修改程序，只需要数据库管理者重新编写存储过程即可。

### 创建存储过程(CREATE PROCEDURE)

语句格式如下

```sql
DELIMITER $$
CREATE PROCEDURE 过程名 (过程参数列表)
BEGIN
存储过程体
END $$

-- 过程参数列表格式
(过程参数类型 参数名 数据类型 ,过程参数类型 参数名 数据类型)
```

说明：

- DELIMITER 命令  
将结束命令修改为其他字符，$$ 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个“?”或两个“￥”等。当使用 DELIMITER 命令时，应该避免使用反斜杠“\”字符，因为它是 MySQL 的转义字符。  
若希望换回默认的分号“;”作为结束标志，则在 MySQL 命令行客户端输入下列语句即可：`DELIMITER ;`  
DELIMITER 和分号“;”之间一定要有一个空格。在创建存储过程时，必须具有 CREATE ROUTINE 权限。
- 过程名  
  存储过程的名称，默认在当前数据库中创建。若需要在特定数据库中创建存储过程，则要在名称前面加上数据库的名称，即 `数据库名.过程名`。
- 过程参数  
  MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入/输出参数，分别用 `IN`、`OUT` 和 `INOUT` 三个关键字标识。其中，输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入/输出参数既可以充当输入参数也可以充当输出参数。  
  需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错信息，但是存储过程的 SQL 语句会将参数名看作列名，从而引发不可预知的结果。
- 过程体  
  在 MySQL 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符，那么 MySQL 服务器在处理时会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的结束符，而不再去处理存储过程体中后面的 SQL 语句，这样显然不行。  
  为解决以上问题，通常使用 `DELIMITER` 命令将结束命令修改为其他字符。

### 查看存储过程

语句格式如下：

```sql
-- 查看存储过程状态
SHOW PROCEDURE STATUS LIKE '存储过程名';

-- 查看存储过程定义
SHOW CREATE PROCEDURE 存储过程名;
```

存储过程的信息都存储在 information_schema 数据库下的 Routines 表中，可以通过查询该表的记录来查询存储过程的信息，SQL 语句如下

```sql
SELECT * FROM information_schema.Routines 
WHERE ROUTINE_NAME=存储过程名;
```

### 修改存储过程特征

MySQL 中修改存储过程的语法格式如下：

```sql
ALTER PROCEDURE 存储过程名 [ 特征 ... ]
```

特征指定了存储过程的特性，可能的取值有：

- CONTAINS SQL 表示子程序包含 SQL 语句，但不包含读或写数据的语句。
- NO SQL 表示子程序中不包含 SQL 语句。
- READS SQL DATA 表示子程序中包含读数据的语句。
- MODIFIES SQL DATA 表示子程序中包含写数据的语句。
- SQL SECURITY { DEFINER |INVOKER } 指明谁有权限来执行。
- DEFINER 表示只有定义者自己才能够执行。
- INVOKER 表示调用者可以执行。
- COMMENT 'string' 表示注释信息。

>ALTER PROCEDURE 语句用于修改存储过程的某些特征。如果要修改存储过程的内容，可以先删除原存储过程，再以相同的命名创建新的存储过程；如果要修改存储过程的名称，可以先删除原存储过程，再以不同的命名创建新的存储过程。

### 删除存储过程

语句格式如下：

```sql
DROP PROCEDURE IF EXISTS 过程参数名；
```

### 存储函数

存储函数和存储过程一样，都是在数据库中定义一些 SQL 语句的集合。存储函数可以通过 return 语句返回函数值，主要用于计算并返回一个值。而存储过程没有直接返回值，主要用于执行操作。

语句格式如下：

```sql
DELIMITER $$
CREATE FUNCTION 存储函数名(参数列表)
RETURNS 数据类型
BEGIN
存储函数体
RETURN 返回值;
END $$

-- 参数列表，参数类型只有IN一种
IN 参数名称 数据类型, 

-- 例子
DELIMITER //
CREATE FUNCTION func_student(id INT(11))
RETURNS VARCHAR(20)
COMMENT '查询某个学生的姓名'
BEGIN
RETURN(SELECT name FROM tb_student WHERE tb_student.id = id);
END //
```

注意：在具体创建函数时，函数名不能与已经存在的函数名重名。除了上述要求外，推荐函数名命名（标识符）为 function_xxx 或者 func_xxx。

存储函数和存储过程的查看、修改、删除等操作几乎相同，只是关键字`PROCEDURE`替换成`FUNCTION`。

### 调用存储过程和存储函数

#### 存储过程调用

```sql
-- 存储过程定义
DELIMITER //
CREATE PROCEDURE 存储过程名(IN 参数1, OUT 参数2)
BEGIN
存储过程体
END//
DELIMITER ;
-- 存储过程调用
CALL 存储过程名(实参1,@参数2);
/*
输入参数直接赋值实参，输出参数直接用 @参数名 的格式调用*/
```

#### 存储函数调用

在 MySQL 中，存储函数的使用方法与 MySQL 内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与 MySQL 内部函数是一个性质的。区别在于，存储函数是用户自己定义的，而内部函数是 MySQL 开发者定义的。

```sql
存储函数名(实参)
```

### 变量的使用

在 MySQL 中，除了支持标准的存储过程和函数外，还引入了表达式。表达式与其它高级语言的表达式一样，由变量、运算符和流程控制来构成。

变量是表达式语句中最基本的元素，可以用来临时存储数据。在存储过程和函数中都可以定义和使用变量。用户可以使用 `DECLARE` 关键字来定义变量，定义后可以为变量赋值。这些变量的作用范围是 `BEGIN...END` 程序段中。

#### 定义变量

语法格式如下：

```sql
-- 局部变量：能用在begin/end语句块中，比如存储过程中的begin/end语句块。
DECLARE 变量名 数据类型 [DEFAULT 默认值];

-- 用户变量：用户变量不用提前申明，在用的时候直接用“@变量名”使用就可以了。其作用域为当前连接。

SET @用户变量名 = 值;
SET @用户变量名 := 值;
SELECT @用户变量名 := 值;

```

#### 变量赋值

语法格式如下：

```sql
-- 方法1：SET语句
SET 变量1=值1或表达式1, 变量2=值2或表达式2;--  表达式可以是SELECT语句

-- 方法2： INSERT INTO语句
INSERT 变量名 INTO 查询字段 FROM 数据表
WHERE 条件子句;
```

### 流程控制语句-判断

在存储过程和自定义函数中可以使用流程控制语句来控制程序的流程。MySQL 中流程控制语句有：IF 语句、CASE 语句、LOOP 语句、LEAVE 语句、ITERATE 语句、REPEAT 语句和 WHILE 语句等。

#### IF从句

```sql
IF 条件判断子句1 THEN 执行语句1;
ELSEIF 条件判断子句2 THEN 执行语句2;
ELSE 执行语句;
END IF;

-- 例子
IF @age>20 THEN SET @count=@count+1;
   ELSEIF @age=20 THEN @count2=@count2+1;
    ELSE @count3=@count3+1;
END IF;
```

#### CASE从句

```sql
-- 格式1
CASE case_value
     WHEN when_value THEN statement_list;
     WHEN when_value THEN statement_list;
     ELSE statement_list;
END CASE;

--格式2
CASE
    WHEN 条件判断 THEN statement_list;
    WHEN 条件判断 THEN statement_list;
    ELSE statement_list;
END CASE;

-- 例1
CASE age
    WHEN 20 THEN SET @count1=@count1+1;
    ELSE SET @count2=@count2+1;
END CASE;

-- 例2
CASE
    WHEN age=20 THEN SET @count1=@count1+1;
    ELSE SET @count2=@count2+1;
END CASE;
```

### 流程控制语句-循环

#### LOOP、LEAVE和ITERATE语句

`LOOP` 语句可以使某些特定的语句重复执行，单独使用的话不会主动跳出循环；

```sql
[循环标志:]LOOP
    执行语句
END LOOP [循环标志]
-- 其中，begin_label 参数和 end_label 参数分别表示循环开始和结束的标志，这两个标志必须相同，而且都可以省略；
```

`LEAVE`语句用于跳出循环控制，语法格式为`LEAVE 循环标志;`;

```sql
add_num:LOOP
    SET @count=@count+1;
    IF @count=100 THEN
        LEAVE add_num;
END LOOP add_num;
```

`ITERATE` 用来跳出本次循环，直接进入下一次循环，语句格式为`ITERATE 循环标志;`

```sql
add_num:LOOP
    SET @count=@count+1;
    IF @count=100 THEN
        LEAVE add_num;
    ELSE IF MOD(@count,3)=0 THEN
        ITERATE add_num;
    SELECT * FROM employee;
END LOOP add_num;
```

#### REPEAT语句

REPEAT 语句是有条件控制的循环语句，每次语句执行完毕后，会对条件表达式进行判断，如果表达式返回值为 TRUE，则循环结束，否则重复执行循环中的语句。

```sql
[循环标志:]REPEAT
执行语句;
UNTIL 循环结束判断语句 
END REPEAT [循环标志];

-- 例子
REPEAT
    SET @count=@count+1;
    UNTIL @count=100
END REPEAT;
```

#### WHILE语句

WHILE 语句也是有条件控制的循环语句。WHILE 语句和 REPEAT 语句不同的是，WHILE 语句是当满足条件时，执行循环内的语句，否则退出循环。WHILE 语句的基本语法形式如下：

```sql
[循环标志:]WHILE 循环开始判断语句
                执行语句;
          END WHILE[循环标志];
-- 例子
WHILE @count<100 DO
    SET @count=@count+1;
END WHILE;
```

### MySQL游标(CURSOR)

游标类似于数组里的下标，只是在MySQL里作为的是数据表里每条记录的下标。  
游标一般配合循环语句用作记录的遍历。

#### 声明游标

用 DECLARE 关键字来声明游标，并定义相应的 SELECT 语句，根据需要添加 WHERE 和其它子句。其语法的基本形式如下：

```sql
-- 为查询的记录添加游标
DECLARE 游标名 CURSOR FOR SELECT语句;
```

#### 打开游标

声明游标之后，要想从游标中提取数据，必须首先打开游标。在 MySQL 中，打开游标通过 OPEN 关键字来实现，其语法格式如下：

```sql
OPEN 游标名;
```

注意：

- 打开一个游标时，游标并不指向第一条记录，而是指向第一条记录的前边。
- 在程序中，一个游标可以打开多次。
- 用户打开游标后，其他用户或程序可能正在更新数据表，所以有时会导致用户每次打开游标后，显示的结果都不同。

#### 使用游标

游标打开后，可以使用 FETCH...INTO 语句来读取当前游标指向的记录，其语法形式如下：

```sql
 -- 一条记录可能有多个字段，所以需要多个变量存储
FETCH 游标名 INTO 变量1,变量2,...;
```

变量必须在游标使用之前定义。使用游标**类似高级语言中的数组遍历**，当第一次使用游标时，此时游标指向结果集的第一条记录。

MySQL 的游标是只读的，也就是说，你只能顺序地从开始往后读取结果集，不能从后往前，也不能直接跳到中间

#### 关闭游标

游标使用完毕后，要及时关闭，其语法格式如下：

```sql
CLOSE 游标名;
```

使用关闭后的游标不需要再次声明，用 OPEN 语句打开它就可以了。

## MySQL触发器

MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，而是通过对数据表的相关操作来触发、激活从而实现执行。  

在 MySQL 中，只有执行 INSERT、UPDATE 和 DELETE 操作时才能激活触发器，其它 SQL 语句则不会激活触发器。

> 那么为什么要使用触发器呢？比如，在实际开发项目时，我们经常会遇到以下情况：
>
> - 在学生表中添加一条关于学生的记录时，学生的总数就必须同时改变。
>- 增加一条学生记录时，需要检查年龄是否符合范围要求。
>- 删除一条学生信息时，需要删除其成绩表上的对应记录。
>- 删除一条数据时，需要在数据库存档表中保留一个备份副本。  
>虽然上述情况实现的业务逻辑不同，但是它们都需要在数据表发生更改时，自动进行一些处理。这时就可以使用触发器处理。例如，对于第一种情况，可以创建一个触发器对象，每当添加一条学生记录时，就执行一次计算学生总数的操作，这样就可以保证每次添加一条学生记录后，学生总数和学生记录数是一致的。

### 支持触发器类型

MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。

1) INSERT 触发器  
   在 INSERT 语句执行之前或之后响应的触发器。  
   使用 INSERT 触发器需要注意以下几点：  
   - 在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。  
   - 在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。  
   - 对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。
2) UPDATE 触发器  
   在 UPDATE 语句执行之前或之后响应的触发器。  
   使用 UPDATE 触发器需要注意以下几点：
   - 在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。
   - 在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。
   - 在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。OLD 中的值全部是只读的，不能被更新。
    
   注意：当触发器设计对触发表自身的更新操作时，只能使用 BEFORE 类型的触发器，AFTER 类型的触发器将不被允许。
3) DELETE 触发器  
   在 DELETE 语句执行之前或之后响应的触发器。  
   使用 DELETE 触发器需要注意以下几点：
   - 在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。
   - OLD 中的值全部是只读的，不能被更新。

总体来说，触发器使用的过程中，MySQL 会按照以下方式来处理错误。

对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。

若 BEFORE 触发程序失败，则 MySQL 将不执行相应行上的操作。

若在 BEFORE 或 AFTER 触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。

仅当 BEFORE 触发程序和行操作均已被成功执行，MySQL 才会执行 AFTER 触发程序。

> MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。  
> 具体地：
>
> - 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；
> - 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；
> - 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；
使用方法： NEW.columnName （columnName 为相应数据表某一列名）
>- OLD 是只读的，而 NEW 则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用。

### 触发器创建(CREATE TRIGGER)

语法格式如下：

```sql
DELIMITER //
CREATE TRIGGER 触发器名 触发时刻 触发器类型 ON 表名 
FOR EACH ROW
BEGIN
触发执行语句//
END //

-- 例子
/*创建一个名为 SumOfSalary 的触发器，触发的条件是向数据表 tb_emp8 中插入数据之前，
对新插入的 salary 字段值进行求和计算。
*/
CREATE TRIGGER SumOfSalary
     BEFORE INSERT ON tb_emp8
     FOR EACH ROW
     SET @sum=@sum+NEW.salary;
```

说明：

1) 触发器名  
   触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。  
2) 触发器事件  
   触发事件只有三种`INSERT  UPDATE  DELETE`  
   注意：三种触发器的执行时间如下。  
   INSERT：将新行插入表时激活触发器。例如，INSERT 的 BEFORE 触发器不仅能被 MySQL 的 INSERT 语句激活，也能被 LOAD DATA 语句激活。  
   DELETE： 从表中删除某一行数据时激活触发器，例如 DELETE 和 REPLACE 语句。  
   UPDATE：更改表中某一行数据时激活触发器，例如 UPDATE 语句。
3) 触发时刻  
   BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。  
   若希望验证新数据是否满足条件，则使用 BEFORE 选项；  
   若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。
4) 表名  
   与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。
   > 例如，对于一张数据表，不能同时有两个 BEFORE UPDATE 触发器，但可以有一个 BEFORE UPDATE 触发器和一个 BEFORE INSERT 触发器，或一个 BEFORE UPDATE 触发器和一个 AFTER UPDATE 触发器。
5) 触发器主体  
   触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。
6) FOR EACH ROW  
   一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。例如，使用 INSERT 语句向某个表中插入多行数据时，触发器会对每一行数据的插入都执行相应的触发器动作。
  
> 注意：每个表都支持 INSERT、UPDATE 和 DELETE 的 BEFORE 与 AFTER，因此每个表最多支持 6 个触发器。每个表的每个事件每次只允许有一个触发器。单一触发器不能与多个事件或多个表关联。

### 查看触发器

```sql
-- 查看数据库中已有的触发器
SHOW TRIGGERS; 
```

### 删除触发器

```sql
DROP TRIGGER [ IF EXISTS ] [数据库名] 触发器名;
```

说明：

- 指定触发器所在的数据库的名称。若没有指定，则为当前默认的数据库
- 删除一个表的同时，也会自动删除该表上的触发器。另外，触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，再重新创建。



## 用户管理

MySQL 是一个多用户数据库，具有功能强大的访问控制系统，可以为不同用户指定不同权限。在前面的章节中我们使用的是 root 用户，该用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户密码等管理权限。

### user表

MySQL 在安装时会自动创建一个名为 mysql 的数据库，mysql 数据库中存储的都是用户权限表。用户登录以后，MySQL 会根据这些权限表的内容为每个用户赋予相应的权限。

user 表是mysql库中最重要的一个权限表，用来记录允许连接到服务器的账号信息。

user 表中的字段大致可以分为 4 类，分别是**用户列、权限列、安全列和资源控制列**，下面主要介绍这些字段的含义。

#### 用户列字段

用户列存储了用户连接 MySQL 数据库时需要输入的信息。

用户登录时，如果这 3 个字段同时匹配，MySQL 数据库系统才会允许其登录。创建新用户时，也是设置这 3 个字段的值。修改用户密码时，实际就是修改 user 表的 authentication_string 字段的值。

字段名| 字段类型 |是否为空| 默认值| 说明
---|---|---|---|---
Host| char(60)| NO| 无| 主机名
User| char(32)| NO| 无| 用户名
authentication_string |text |YES| 无| 密码

#### 权限列字段

权限列的字段决定了用户的权限，用来描述在全局范围内允许对数据和数据库进行的操作。

权限大致分为两大类，分别是高级管理权限和普通权限：

高级管理权限主要对数据库进行管理，例如关闭服务的权限、超级权限和加载用户等；
普通权限主要操作数据库，例如查询权限、修改权限等。

user 表的权限列包括 Select_priv、Insert_ priv 等以 priv 结尾的字段，这些字段值的数据类型为 ENUM，可取的值只有 Y 和 N：Y 表示该用户有对应的权限，N 表示该用户没有对应的权限。从安全角度考虑，这些字段的默认值都为 N。

![图片alt](权限列字段.png "权限列字段")

#### 安全列字段

安全列主要用来判断用户是否能够登录成功

#### 资源控制列

资源控制列的字段用来限制用户使用的资源

### 查询用户

语句格式如下：

```sql
SELECT user FROM mysql.user;
```

### 创建用户

语句格式如下：

```sql

-- 方法1
CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';

--方法2
/*由于 mysql 数据库的 user 表中，ssl_cipher、x509_issuer 和 x509_subject 这 3 个字段没有默认值，
所以向 user 表插入新记录时，一定要设置这 3 个字段的值，否则 INSERT 语句将不能执行。*/
INSERT INTO mysql.user(Host, User,authentication_string, ssl_cipher, x509_issuer, x509_subject) 
VALUES ('hostname', 'username', PASSWORD('password'), '', '', '');

-- 例子
-- %：表示所有的主机,localhost就不用说了吧，本机啊。
create user 'gaoxin'@'%' identified by '123456';
create user 'zhagnsan'@'localhost' identified by '123';

```

使用 CREATE USER 语句必须拥有 mysql 数据库的 INSERT 权限或全局 CREATE USER 权限。

新创建的用户拥有的权限很少，它们只能执行不需要权限的操作。如登录 MySQL、使用 SHOW 语句查询所有存储引擎和字符集的列表等。如果两个用户的用户名相同，但主机名不同，MySQL 会将它们视为两个用户，并允许为这两个用户分配不同的权限集合。

### 删除用户

语句格式如下：

```sql
-- 方法1
DROP USER '用户名'@'主机名'

-- 方法2
 DELETE FROM mysql.user
 WHERE Host='主机名' AND User='用户名';


drop user 'gaoxin'@'%';
drop user 'zhagnsan'@'localhost';

```

### 修改用户名

可以使用 `RENAME USER` 语句修改一个或多个已经存在的用户账号名：

```sql
RENAME USER 旧用户名 TO 新用户名;
```

使用 RENAME USER 语句时应注意以下几点：

- RENAME USER 语句用于对原有的 MySQL 用户进行重命名。
- 若系统中旧账户不存在或者新账户已存在，该语句执行时会出现错误。
- 使用 RENAME USER 语句，必须拥有 mysql 数据库的 UPDATE 权限或全局 CREATE USER 权限。

### 用户权限管理

#### 查询用户权限

**方法一**：在mysql.user表里查询用户的权限

语句格式如下

```sql
SELECT * FROM mysql.user
```

要执行该语句，必须拥有对 user 表的查询权限。

新创建的用户只有登录 MySQL 服务器的权限，没有任何其它权限，不能查询 user 表。

**方法二**：使用 `SHOW GRANTS FOR` 语句查看权限

语句格式如下：

```sql
SHOW GRANTS FOR '用户名'@'主机名';
```

#### 授予用户权限

语句格式如下：

```sql
GRANT 权限1[(字段列表)],权限2 ON 权限作用范围 TO '用户名1'@'主机名1' 
[IDENTIFIED BY '用户新密码']
[WITH with选项]
, '用户名2'@'主机名2';
```

说明：

- 同时对多个用户授予权限时，可以用`,`隔开；
- WITH 关键字后面带有一个或多个 with_option 参数。这个参数有 5 个选项，详细介绍如下：
  
  > - GRANT OPTION：被授权的用户可以将这些权限赋予给别的用户；
  > - MAX_QUERIES_PER_HOUR count：设置每个小时可以允许执行 count 次查询；
  >- MAX_UPDATES_PER_HOUR count：设置每个小时可以允许执行 count 次更新；
  >- MAX_CONNECTIONS_PER_HOUR count：设置每小时可以建立 count 个连接;
  >- MAX_USER_CONNECTIONS count：设置单个用户可以同时具有的 count 个连接。

- MySQL 中可以授予的权限从低到高有如下几组：

  >- 列权限，和表中的一个具体列相关。例如，可以使用 UPDATE 语句更新表 students 中 name 列的值的权限。
  >- 表权限，和一个具体表中的所有数据相关。例如，可以使用 SELECT 语句查询表 students 的所有数据的权限。
  >- 数据库权限，和一个具体的数据库中的所有表相关。例如，可以在已有的数据库 mytest 中创建新表的权限。
  >- 用户权限，和 MySQL 中所有的数据库相关。例如，可以删除已有的数据库或者创建一个新的数据库的权限。

- 相对应的权限作用范围有以下几类格式描述：
  
  ```sql
  -- 列权限语句格式
  GRANT 权限名称(字段1,字段2) ON 数据库.数据表 TO '用户名'@'主机名'

  -- 表权限语句格式
  GRANT 权限1,权限2 ON 数据库.数据表 TO '用户名'@'主机名'

  -- 数据库权限语句格式
   GRANT 权限1,权限2 ON 数据库.* TO '用户名'@'主机名'
  
  -- 用户权限
   GRANT 权限1,权限2 ON *.* TO '用户名'@'主机名'
  ```

- TO 子句：如果权限被授予给一个不存在的用户，MySQL 会自动执行一条 CREATE USER 语句来创建这个用户，但同时必须为该用户设置密码。

#### 删除用户权限

语句格式如下：

```sql
-- 删除指定权限
REVOKE 权限名1[(字段列表)], 权限名2[(字段列表)] 
ON 权限范围 FROM 
'username1'@'hostname1', 'username1'@'hostname1'

-- 删除全部权限
REVOKE ALL PRIVILEGES, GRANT OPTION 
ON 权限范围 FROM 
'username1'@'hostname1', 'username1'@'hostname1'
```

删除用户权限需要注意以下几点：

- REVOKE 语法和 GRANT 语句的语法格式相似，但具有相反的效果。
- 要使用 REVOKE 语句，必须拥有 MySQL 数据库的全局 CREATE USER 权限或 UPDATE 权限。

#### 权限类型

##### 列权限

授予列权限时，权限类型的值只能指定为 `SELECT`、`INSERT` 和 `UPDATE`，同时权限的后面需要加上作用字段列表。

##### 数据表权限

权限名称| 对应user表中的字段| 说明
---|---|---
SELECT| Select_priv| 授予用户可以使用 SELECT 语句进行访问特定表的权限
INSERT| Insert_priv| 授予用户可以使用 INSERT 语句向一个特定表中添加数据行的权限
DELETE| Delete_priv |授予用户可以使用 DELETE 语句从一个特定表中删除数据行的权限
DROP| Drop_priv| 授予用户可以删除数据表的权限
UPDATE| Update_priv| 授予用户可以使用 UPDATE 语句更新特定数据表的权限
ALTER |Alter_priv | 授予用户可以使用 ALTER TABLE 语句修改数据表的权限
REFERENCES| References_priv| 授予用户可以创建一个外键来参照特定数据表的权限
CREATE| Create_priv| 授予用户可以使用特定的名字创建一个数据表的权限
INDEX |Index_priv| 授予用户可以在表上定义索引的权限
ALL 或 ALL PRIVILEGES 或 SUPER| Super_priv| 所有的权限名

##### 数据库权限

权限名称| 对应user表中的字段| 说明
---|---|---
SELECT| Select_priv |表示授予用户可以使用 SELECT 语句访问特定数据库中所有表和视图的权限。
INSERT| Insert_priv| 表示授予用户可以使用 INSERT 语句向特定数据库中所有表添加数据行的权限。
DELETE| Delete_priv |表示授予用户可以使用 DELETE 语句删除特定数据库中所有表的数据行的权限。
UPDATE| Update_priv| 表示授予用户可以使用 UPDATE 语句更新特定数据库中所有数据表的值的权限。
REFERENCES| References_priv| 表示授予用户可以创建指向特定的数据库中的表外键的权限。
CREATE| Create_priv| 表示授权用户可以使用 CREATE TABLE 语句在特定数据库中创建新表的权限。
ALTER |Alter_priv|  表示授予用户可以使用 ALTER TABLE 语句修改特定数据库中所有数据表的权限。
SHOW |VIEW Show_view_priv| 表示授予用户可以查看特定数据库中已有视图的视图定义的权限。
CREATE ROUTINE| Create_routine_priv| 表示授予用户可以为特定的数据库创建存储过程和存储函数的权限。
ALTER ROUTINE| Alter_routine_priv| 表示授予用户可以更新和删除数据库中已有的存储过程和存储函数的权限。
INDEX| Index_priv| 表示授予用户可以在特定数据库中的所有数据表上定义和删除索引的权限。
DROP| Drop_priv| 表示授予用户可以删除特定数据库中所有表和视图的权限。
CREATE TEMPORARY TABLES| Create_tmp_table_priv| 表示授予用户可以在特定数据库中创建临时表的权限。
CREATE VIEW |Create_view_priv| 表示授予用户可以在特定数据库中创建新的视图的权限。
EXECUTE ROUTINE| Execute_priv| 表示授予用户可以调用特定数据库的存储过程和存储函数的权限。
LOCK TABLES| Lock_tables_priv |表示授予用户可以锁定特定数据库的已有数据表的权限。
ALL 或 ALL PRIVILEGES 或 SUPER| Super_priv |表示以上所有权限/超级权限

##### 用户权限

授予用户权限时，<权限类型>除了可以指定为授予数据库权限时的所有值之外，还可以是下面这些值：

- CREATE USER：表示授予用户可以创建和删除新用户的权限。
- SHOW DATABASES：表示授予用户可以使用 SHOW DATABASES 语句查看所有已有的数据库的定义的权限。

### 用户登录和退出

启动mysql服务后，用下列命令进行登录：

```sql
mysql -h 主机名或主机ip -p 端口号 -u 用户名 -p 密码
```

对上述参数说明如下：

- -h：指定连接 MySQL 服务器的地址。可以用两种方式表示， hostname 为主机名，hostIP 为主机 IP 地址。
- -p：指定连接 MySQL 服务器的端口号，port 为连接的端口号。MySQL 的默认端口号是 3306，因此如果不指定该参数，默认使用 3306 连接 MySQL 服务器。
- -u：指定连接 MySQL 服务器的用户名，username 为用户名。
- -p：提示输入密码，即提示 Enter password。

退出MySQL的命令为`EXIT`活`QUIT`。

### 用户修改密码

#### 普通用户修改自己密码

语句格式如下：

```sql
SET PASSWORD=PASSWORD('新密码');
```

注意：新密码必须使用 PASSWORD() 函数来加密，如果不使用 PASSWORD() 加密，也会执行成功，但是用户会无法登录。

#### root用户修改普通用户密码

语句格式如下：

```sql
-- 方法1 ：使用SET PASSWORD语句
SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');

-- 方法2: 使用UPDATE语句
UPDATE mysql.user SET authentication_string = PASSWORD("新密码") 
WHERE User='用户名' AND Host='主机名';

-- 方法3: 使用GRANT语句
GRANT USAGE ON *.* TO '用户名'@'主机名' IDENTIFIED BY '新密码';
```

注意的是，使用 GRANT 语句修改密码，必须拥有 GRANT 权限。一般情况下最好使用该方法来指定或修改密码。

#### 修改root用户密码

语句格式如下

```sql
-- 方法1：使用mysqladmin命令
mysqladmin -u username -h hostname -p password "新密码"

-- 方法2：修改mysql.user数据表记录
UPDATE mysql.user SET authentication_string = PASSWORD("新密码")  
WHERE User='root用户名' AND Host='主机名';

-- 方法3：使用SET语句
SET PASSWORD=PASSWORD("新密码");
```

注意：使用`UPDATE`和`SET`语句都要事先登录到root用户。
